# 수의 체계

날짜: 2025년 3월 25일
학습 상태: 학습중
복습 필요: No

### 📌 **이진수 정수 연산과 보수 요약**

---

## **1️⃣ 이진수 정수 연산**

🔹 **덧셈**

- 1 + 1 = **10** (자리올림 발생)
- 예: `1011₂ + 1101₂ = 11000₂`

🔹 **뺄셈**

- 자리 차용(빌림) 사용
- 예: `1011₂ - 0110₂ = 0101₂`

🔹 **곱셈**

- 십진수와 같은 원리
- 예: `101₂ × 11₂ = 1111₂`

🔹 **나눗셈**

- 십진수 나눗셈과 동일
- 예: `10110₂ ÷ 10₂ = 1011₂`

---

## **2️⃣ 이진수의 보수 (Complement)**

✅ **1의 보수 (One’s Complement)**

- 각 비트를 반전 (0 → 1, 1 → 0)
- 예: `1011₂ → 0100₂`

✅ **2의 보수 (Two’s Complement)**

- 1의 보수 + 1
- 예: `1011₂ → 0100₂ → 0101₂`

💡 **2의 보수는 컴퓨터에서 음수 표현에 사용됨!**

✅ **보수를 이용한 뺄셈**

`1011₂ - 0110₂` 를 2의 보수로 계산하면:

1. `0110₂`의 2의 보수 = `1010₂`
2. `1011₂ + 1010₂ = 10101₂` → (첫 번째 비트 버림) → `0101₂` (결과)

---

## **3️⃣ 이진수 음수 표현 방식**

| 표현 방식 | 설명 | 예 (4비트) |
| --- | --- | --- |
| **부호와 절대치** | 최상위 비트(MSB)가 부호비트 (0 = 양수, 1 = 음수) | `-3 → 1001₂` |
| **1의 보수** | 모든 비트를 반전 | `-3 → 1100₂` |
| **2의 보수** | 1의 보수 + 1 | `-3 → 1101₂` |

---

## **4️⃣ 오버플로우 (Overflow)**

- **양수 + 양수 → 음수** 또는 **음수 + 음수 → 양수**가 발생하면 **오버플로우**
- 예: `98 + 74 = -84 (8비트 연산 시)`

✅ 해결 방법: **부호 확장(Sign Extension)**

- 8비트 → 16비트 확장 시 올바른 결과 도출 가능